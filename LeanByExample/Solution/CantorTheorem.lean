/- # Cantor ã®å®šç†

Cantor ã®å®šç†ã¨ã¯ã€æ¬¡ã®ã‚ˆã†ãªå®šç†ã§ã™ã€‚

```admonish info title=""
ã©ã‚“ãªé›†åˆ `A` ã«å¯¾ã—ã¦ã‚‚ `A` ã‚ˆã‚Š `A` ã®ãƒ™ã‚­é›†åˆ `ğ’« A` ã®æ–¹ãŒçœŸã«æ¿ƒåº¦ãŒå¤§ãããªã‚Šã¾ã™ã€‚

ãŸã ã—ã“ã“ã§ã€ŒçœŸã«æ¿ƒåº¦ãŒå¤§ãã„ã€ã¨ã¯ã€

1. `A` ã‹ã‚‰ `ğ’« A` ã¸ã®å…¨å°„ãŒå­˜åœ¨ã—ãªã„
1. `ğ’« A` ã‹ã‚‰ `A` ã¸ã®å˜å°„ãŒå­˜åœ¨ã—ãªã„

ã¨ã„ã†ã“ã¨ã‚’æ„å‘³ã—ã¦ã„ã¾ã™ã€‚
```

ã€Œæ¿ƒåº¦ã€ã¨ã¯ã€é›†åˆã®ã€Œè¦ç´ ã®å€‹æ•°ã€ã¨ã„ã†æ¦‚å¿µã‚’ç„¡é™é›†åˆã«ã‚‚æ‹¡å¼µã—ãŸã‚‚ã®ã§ã‚ã‚Šã€ãŠãŠã‚€ã­ã€Œä¸€å¯¾ä¸€ã§æ¼ã‚Œã®ãªã„å¯¾å¿œãŒã¤ã‘ã‚‰ã‚Œã‚‹ãªã‚‰ã°ã€è¦ç´ æ•°ãŒç­‰ã—ã„ã¨è¨€ã£ã¦ã‚ˆã„ã ã‚ã†ã€ã¨ã„ã†ã‚¢ã‚¤ãƒ‡ã‚¢ã«åŸºã¥ãã‚‚ã®ã§ã™ã€‚

ã“ã® Cantor ã®å®šç†ã¯ã‚ˆãçŸ¥ã‚‰ã‚ŒãŸã‚‚ã®ã§ã‚ã‚Šã€Mathlib ã«ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™ãŒã€ã“ã“ã§ã¯ Lean ã‚’ç”¨ã„ã¦æ•°å­¦ç†è«–ã‚’å½¢å¼åŒ–ã™ã‚‹ã¨ã¯ã©ã†ã„ã†ã“ã¨ã‹ãŠè¦‹ã›ã™ã‚‹ãŸã‚ã«ã€Mathlib ã‚’ä¸€åˆ‡ä½¿ã‚ãšã«å½¢å¼åŒ–ã—ã¦ã„ãã¾ã™ã€‚
-/

/- ## é›†åˆè«–ã®å½¢å¼åŒ–

### å…¨ä½“é›†åˆã‚’å›ºå®šã™ã‚‹

ã¾ãšã€é›†åˆã®æ¦‚å¿µã‚’ Lean ã§è¡¨ç¾ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

Lean ã®å‹ `T : Type` ã¯ç›´è¦³çš„ã«ã¯ã€Œé …ã®é›†ã¾ã‚Šã€ã‚’æ„å‘³ã™ã‚‹ã®ã§ã€ã“ã‚Œã‚’ãã®ã¾ã¾é›†åˆã ã¨è€ƒãˆã¦ã—ã¾ã£ã¦ã€`t : T` ã‚’ã‚‚ã£ã¦ `t âˆˆ T` ã§ã‚ã‚‹ã¨è¦‹ãªã›ã°ã‚ˆã„ã‚ˆã†ã«æ€ãˆã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã—ã‹ã— Lean ã®å‹ã‚·ã‚¹ãƒ†ãƒ ã®æ€§è³ªä¸Šã€ã“ã®è§£é‡ˆã¯é€”ä¸­ã§ç ´ç¶»ã—ã¾ã™ã€‚

ãŸã¨ãˆã° `S T : Type` ã«å¯¾ã—ã¦å…±é€šéƒ¨åˆ†ã® `S âˆ© T` ã®è¦ç´ ã¯ `S` ã«ã‚‚ `T` ã«ã‚‚å±ã—ã¦ã„ãªãã¦ã¯ã„ã‘ã¾ã›ã‚“ãŒã€ã“ã‚Œã¯å‹ã®ä¸€æ„æ€§ã‹ã‚‰å®Ÿç¾ã§ãã¾ã›ã‚“ã€‚`S âˆª T` ã«ã¤ã„ã¦ã‚‚åŒæ§˜ã§ã€`S` ã«ã‚‚ `S âˆª T` ã«ã‚‚å±ã—ã¦ã„ã‚‹è¦ç´ ã«æ­£ã—ãå‹ã‚’ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚

ãã“ã§å…¨ä½“é›†åˆ `Î± : Type` ã‚’å›ºå®šã—ã¦ã€ãã®ä¸­ã«å«ã¾ã‚Œã‚‹é›†ã¾ã‚Šã ã‘ã‚’è€ƒãˆã‚‹ã“ã¨ã«ã—ã¾ã™ã€‚
-/
import Lean --#
set_option autoImplicit false --#
set_option relaxedAutoImplicit false --#

/-- Î± ã‚’å…¨ä½“é›†åˆã¨ã—ã¦ã€ãã®éƒ¨åˆ†é›†åˆã®å…¨ä½“ã€‚
Î± ã®éƒ¨åˆ†é›†åˆã¨ Î± ä¸Šã®è¿°èªã‚’åŒä¸€è¦–ã—ã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã€‚ -/
def Set (Î± : Type) := Î± â†’ Prop

variable {Î± : Type}

/-- `a : Î±` ã¯é›†åˆ `s` ã«å±ã™ã‚‹ã€‚æ•°å­¦ã§ã¯æ™®é€š `a âˆˆ s` ã¨æ›¸ã‹ã‚Œã‚‹ã€‚ -/
def Set.mem (s : Set Î±) (a : Î±) : Prop := s a

/-- `s a` ã‚’ `a âˆˆ s` ã¨æ›¸ã‘ã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚ -/
instance : Membership Î± (Set Î±) := âŸ¨Set.memâŸ©

/-- `A B : Set Î±` ã«å¯¾ã™ã‚‹å…±é€šéƒ¨åˆ† -/
def Set.inter (A B : Set Î±) : Set Î± := fun x => x âˆˆ A âˆ§ x âˆˆ B

/-- `A B : Set Î±` ã«å¯¾ã™ã‚‹åˆä½µ -/
def Set.union (A B : Set Î±) : Set Î± := fun x => x âˆˆ A âˆ¨ x âˆˆ B

/- ã“ã®ã‚ˆã†ã«ã—ã¦ãŠãã¨ã€ä¸Šè¨˜ã®å•é¡Œã¯å›é¿ã™ã‚‹ã“ã¨ãŒã§ãã€`S T : Set Î±` ã®å…±é€šéƒ¨åˆ†ã‚„åˆä½µã‚’ã¨ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

### å†…åŒ…è¨˜æ³•ã®å®šç¾©

ã€Œè¿°èªã¨éƒ¨åˆ†é›†åˆã‚’åŒä¸€è¦–ã™ã‚‹ã€ã¨ã„ã†è¡¨ç¾ã®è‰¯ããªã„ã¨ã“ã‚ã¯ã€é›†åˆã‚’é–¢æ•°ã¨ã—ã¦æ‰±ã†ã“ã¨ã«ãªã‚‹ã®ã§è¡¨è¨˜ãŒã‚ã‹ã‚Šã«ãããªã‚Šã€æ··ä¹±ã‚’æ‹›ãã‹ã­ãªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚è¿°èª `p : Î± â†’ Prop` ã«å¯¾ã—ã¦å†…åŒ…è¨˜æ³• `{x : Î± | p x}` ãŒä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã—ã‚‡ã†ã€‚

Lean ã®ãƒ¡ã‚¿ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®åŠ›ã‚’å€Ÿã‚Šã‚Œã°ã€ãã†ã—ãŸã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚
-/
section --#

variable {Î± : Type}

/-- è¿°èª `p : Î± â†’ Prop` ã«å¯¾å¿œã™ã‚‹é›†åˆ -/
def setOf {Î± : Type} (p : Î± â†’ Prop) : Set Î± := p

/-- å†…åŒ…è¡¨è¨˜ `{ x : Î± | p x }` ã® `x : Î±` ã®éƒ¨åˆ†ã®ãŸã‚ã®æ§‹æ–‡ã€‚
`: Î±` ã®éƒ¨åˆ†ã¯ã‚ã£ã¦ã‚‚ãªãã¦ã‚‚ã‚ˆã„ã®ã§ `( )?` ã§å›²ã£ã¦ã„ã‚‹ã€‚-/
syntax extBinder := ident (" : " term)?

/-- å†…åŒ…è¡¨è¨˜ `{ x : Î± | p x }` ã® `{ | }` ã®éƒ¨åˆ†ã®ãŸã‚ã®æ§‹æ–‡ã€‚ -/
syntax (name := setBuilder) "{" extBinder " | " term "}" : term

/-- å†…åŒ…è¡¨è¨˜ã®æ„å‘³ã‚’ãƒã‚¯ãƒ­ã¨ã—ã¦å®šç¾©ã™ã‚‹ -/
macro_rules
  | `({ $x:ident : $type | $p }) => `(setOf (fun ($x : $type) => $p))
  | `({ $x:ident | $p }) => `(setOf (fun ($x : _) => $p))

-- å†…åŒ…è¡¨è¨˜ãŒä½¿ãˆã‚‹ã‚ˆã†ã«ãªã£ãŸãŒã€ã‚³ãƒãƒ³ãƒ‰ã®å‡ºåŠ›ã‚„ infoview ã§ã¯
-- ã„ã¾å®šç¾©ã—ãŸè¨˜æ³•ãŒä½¿ã‚ã‚Œãªã„ã¨ã„ã†å•é¡ŒãŒã‚ã‚‹
/-- info: setOf fun n => âˆƒ m, n = 2 * m : Set Nat -/
#guard_msgs in
  #check {n : Nat | âˆƒ m, n = 2 * m}

/-- infoview ã‚„ã‚³ãƒãƒ³ãƒ‰ã®å‡ºåŠ›ã§ã‚‚å†…åŒ…è¡¨è¨˜ã‚’ä½¿ç”¨ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ -/
@[app_unexpander setOf]
def setOf.unexpander : Lean.PrettyPrinter.Unexpander
  | `($_ fun $x:ident => $p) => `({ $x:ident | $p })
  | `($_ fun ($x:ident : $ty:term) => $p) => `({ $x:ident : $ty:term | $p })
  | _ => throw ()

-- æ­£å¸¸ã«å‹•ä½œã™ã‚‹ã“ã¨ã‚’ç¢ºèª

/-- info: {n | âˆƒ m, n = 2 * m} : Set Nat -/
#guard_msgs in
  #check {n | âˆƒ m, n = 2 * m}

/-- info: {n | âˆƒ m, n = 2 * m} : Set Nat -/
#guard_msgs in
  #check {n : Nat | âˆƒ m, n = 2 * m}

end --#

/- ### å…¨å°„ã¨å˜å°„
é–¢æ•° `f : A â†’ B` ãŒå…¨å°„ã§ã‚ã‚‹ã¨ã¯ã€ä»»æ„ã® `b : B` ã«å¯¾ã—ã¦ `f a = b` ã¨ãªã‚‹ `a : A` ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã§ã™ã€‚ã¾ãŸã€`f` ãŒå˜å°„ã§ã‚ã‚‹ã¨ã¯ã€ä»»æ„ã® `aâ‚, aâ‚‚ : A` ã«å¯¾ã—ã¦ `f aâ‚ = f aâ‚‚` ãªã‚‰ã° `aâ‚ = aâ‚‚` ã¨ãªã‚‹ã“ã¨ã§ã™ã€‚

ã“ã‚Œã‚’ Lean ã§è¡¨ç¾ã™ã‚‹ã¨æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
-/
section --#

variable {Î± Î² : Type}

/-- é–¢æ•°ã®å…¨å°„æ€§ -/
def Function.Surjective (f : Î± â†’ Î²) : Prop := âˆ€ b, âˆƒ a, f a = b

/-- é–¢æ•°ã®å˜å°„æ€§ -/
def Function.Injective (f : Î± â†’ Î²) : Prop := âˆ€ {aâ‚ aâ‚‚ : Î±}, f aâ‚ = f aâ‚‚ â†’ aâ‚ = aâ‚‚

end --#
/-
```admonish warning title="æ³¨æ„"
ä¸Šè¨˜ã®å®šç¾©ã‚’è¦‹ã¦ã€é–¢æ•°ã®å®šç¾©åŸŸã¨å€¤åŸŸãŒ `A B : Set Î±` ã§ã¯ãªãã¦ `Î± Î² : Type` ã§ã‚ã‚‹ã“ã¨ã«é•å’Œæ„Ÿã‚’æ„Ÿã˜ã‚‰ã‚ŒãŸã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚å‹ã¨é›†åˆã¯ç•°ãªã‚‹ã¨ä¸Šã§æ›¸ã„ãŸã°ã‹ã‚Šãªã®ã«ã€ãªãœã“ã“ã§ã¯å‹ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ

å®Ÿéš›ã« `A B : Set Î±` ã«å¯¾ã—ã¦é–¢æ•°ã®é›†åˆ `Hom A B` ã‚’å®šç¾©ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€ãã®ç†ç”±ãŒã‚ã‹ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

`f âˆˆ Hom A B` ãŒæŒã¤ã¹ãæ€§è³ªã¨ã—ã¦ `a âˆˆ A â†’ f a âˆˆ B` ãŒã‚ã‚Šã¾ã™ã€‚`A : Set Î±` ã¨ `B : Set Î±` ã‚’ãã‚Œãã‚Œéƒ¨åˆ†å‹ `{ a : Î± // a âˆˆ A }`, `{b : Î± // b âˆˆ B}` ã¨åŒä¸€è¦–ã™ã‚Œã°ã€`Hom A B` ã¯é–¢æ•°å‹ `{ a : Î± // a âˆˆ A } â†’ { b : Î± // b âˆˆ B }` ã«ãªã‚Šã¾ã™ã€‚

çµå±€é–¢æ•°å‹ã‚’è€ƒãˆã¦ã„ã‚‹ã“ã¨ã«ãªã‚‹ã®ã§ã€`Î± Î² : Type` ã«ã¤ã„ã¦è€ƒãˆã‚Œã°ååˆ†ã ã¨ã„ã†ã“ã¨ã«ãªã‚‹ã‚ã‘ã§ã™ã€‚
```
-/

/- ## å•1: å…¨å°„ãƒãƒ¼ã‚¸ãƒ§ãƒ³
ä»¥ä¸Šã®æº–å‚™ã®ã‚‚ã¨ã§ã€Cantor ã®å®šç†ã‚’è¨¼æ˜ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã¾ãšã¯å…¨å°„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‹ã‚‰ç¤ºã—ã¾ã—ã‚‡ã†ã€‚æ¬¡ã® `sorry` ã®éƒ¨åˆ†ã‚’åŸ‹ã‚ã¦ãã ã•ã„ã€‚
-/
section --#

variable {Î± : Type}

open Function

/-- ã‚ã‚‹é›†åˆã‹ã‚‰ãã®ãƒ™ã‚­é›†åˆã¸ã®å…¨å°„ã¯å­˜åœ¨ã—ãªã„ -/
theorem cantor_surjective (f : Î± â†’ Set Î±) : Â¬ Surjective f := by
  -- `f` ãŒå…¨å°„ã§ã‚ã‚‹ã¨ä»®å®šã™ã‚‹
  intro hsurj

  -- åä¾‹ã«ãªã‚‹é›†åˆ `A` ã‚’æ§‹æˆã™ã‚‹
  -- `Î±` ã®éƒ¨åˆ†é›†åˆ `A : Set Î±` ã‚’ `{a | a âˆ‰ f a}` ã§å®šç¾©ã™ã‚‹ --##
  let A : Set Î± := /- sorry -/ {a | a âˆ‰ f a}

  -- `f` ã¯å…¨å°„ãªã®ã§ã€ã‚ã‚‹ `a` ãŒå­˜åœ¨ã—ã¦ `f a = A`
  obtain âŸ¨a, haâŸ© := hsurj A

  -- `a âˆˆ A` ã¯ `a âˆ‰ A` ã¨åŒå€¤ã§ã‚ã‚‹
  have : a âˆˆ A â†” a âˆ‰ A := by
    -- sorry
    -- `f a = A` ãªã®ã§ `a âˆ‰ A` ã¯ `a âˆ‰ f a` ã¨åŒå€¤
    rw [show (a âˆ‰ A) = (a âˆ‰ f a) from by rw [ha]]

    -- `A` ã®å®šç¾©ã‹ã‚‰ `a âˆˆ A` ã¯ `a âˆ‰ f a` ã¨åŒå€¤
    rw [show (a âˆˆ A) â†” (a âˆ‰ f a) from by rfl]
    -- sorry

  -- ã“ã‚Œã¯çŸ›ç›¾
  simp at this

/- ## å•2: å˜å°„ãƒãƒ¼ã‚¸ãƒ§ãƒ³
å˜å°„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚‚ç¤ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚æ¬¡ã® `sorry` ã®éƒ¨åˆ†ã‚’åŸ‹ã‚ã¦ãã ã•ã„ã€‚
-/

/-- ãƒ™ã‚­é›†åˆã‹ã‚‰å…ƒã®é›†åˆã¸ã®å˜å°„ã¯å­˜åœ¨ã—ãªã„ -/
theorem cantor_injective (f : Set Î± â†’ Î±) : Â¬ Injective f := by
  -- `f` ãŒå˜å°„ã ã¨ä»®å®šã™ã‚‹
  intro hinj

  -- åä¾‹ã«ãªã‚‹é›†åˆ `A` ã‚’æ§‹æˆã™ã‚‹
  -- `Î±` ã®éƒ¨åˆ†é›†åˆ `A : Set Î±` ã‚’ `{f B | f B âˆ‰ B}` ã§å®šç¾©ã™ã‚‹ --##
  let A : Set Î± := /- sorry -/ {a | âˆƒ B : Set Î±, a = f B âˆ§ f B âˆ‰ B}

  -- ã“ã®ã¨ã `f A âˆˆ A` ã¨ `f A âˆ‰ A` ãŒåŒå€¤ã«ãªã‚‹
  have : (f A âˆˆ A) â†” (f A âˆ‰ A) := by
    -- sorry
    constructor

    -- å·¦ã‹ã‚‰å³ã‚’ç¤ºã™
    case mp =>
      -- `f A âˆˆ A` ã¨ä»®å®šã™ã‚‹
      intro hmem
      exfalso

      -- `f A âˆˆ A` ãªã®ã§ `A` ã®å®šç¾©ã‹ã‚‰ã€
      -- ã‚ã‚‹ `B : Set Î±` ãŒå­˜åœ¨ã—ã¦ `f A = f B` ã‹ã¤ `f B âˆ‰ B`
      have âŸ¨B, hf, hBâŸ© := hmem

      -- `f` ã¯å˜å°„ãªã®ã§ `A = B` ã§ã‚ã‚‹
      have hAB : A = B := hinj hf

      -- ã“ã‚Œã¯ `f A âˆ‰ A` ã‚’æ„å‘³ã—ã€çŸ›ç›¾
      rw [â† hAB] at hB
      contradiction

    -- å³ã‹ã‚‰å·¦ã‚’ç¤ºã™
    case mpr =>
      -- `f A âˆ‰ A` ã¨ä»®å®šã™ã‚‹
      intro hmem

      -- `A` ã®å®šç¾©ã«ã‚ˆã‚Šã€ã“ã‚Œã¯ã¾ã•ã« `f A âˆˆ A` ã‚’æ„å‘³ã™ã‚‹
      -- ã‚ˆã£ã¦çŸ›ç›¾
      exact âŸ¨A, rfl, hmemâŸ©
    -- sorry

  -- ã“ã‚Œã¯çŸ›ç›¾ã§ã‚ã‚‹
  simp at this
end --#

/-
```admonish warning title="æ³¨æ„"
[å…¨å°„(å˜å°„)ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã¨ã€é€†æ–¹å‘ã®å˜å°„(å…¨å°„)ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã¯ã»ã¼åŒå€¤](./InverseSurjInj.md)ãªã®ã§ã€ãã‚Œã‚’ä½¿ãˆã°å…¨å°„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«å¸°ç€ã—ã¦ç¤ºã›ã‚‹ã“ã¨ã«ãŠæ°—ã¥ãã§ã—ã‚‡ã†ã‹ã€‚ã—ã‹ã—ã€ãã‚Œã‚’ãã®ã¾ã¾ä½¿ã†ã¨é¸æŠåŸç†ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã“ã“ã§ã¯é¸æŠåŸç†ã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚
```
-/

--#--
section
/- ## é¸æŠåŸç†ã‚’ä½¿ç”¨ã—ã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã‚³ãƒãƒ³ãƒ‰ -/

open Lean Elab Command

elab "#detect_classical " id:ident : command => do
  let constName â† liftCoreM <| realizeGlobalConstNoOverload id
  let axioms â† collectAxioms constName
  if axioms.isEmpty then
    logInfo m!"'{constName}' does not depend on any axioms"
    return ()
  let caxes := axioms.filter fun nm => Name.isPrefixOf `Classical nm
  if caxes.isEmpty then
    logInfo m!"'{constName}' is non-classical and depends on axioms: {axioms.toList}"
  else
    throwError m!"'{constName}' depends on classical axioms: {caxes.toList}"

end

-- é¸æŠåŸç†ã‚’ä½¿ç”¨ã—ã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
#detect_classical cantor_surjective
#detect_classical cantor_injective
--#--
